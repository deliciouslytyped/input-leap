// This file was mostly generated by an LLM.

/*
 * InputLeap -- mouse and keyboard sharing utility
 * Copyright (C) 2026 InputLeap contributors
 *
 * This package is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * found in the file LICENSE that should have accompanied this file.
 *
 * This package is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "platform/MSWindowsImpersonation.h"

#ifdef SYSAPI_WIN32

#include "base/Log.h"
#include <WtsApi32.h>
#include <Shlobj.h>
#include <KnownFolders.h>

#pragma comment(lib, "Wtsapi32.lib")
#pragma comment(lib, "Shell32.lib")

namespace inputleap {

    bool enablePrivilege(const char* privilegeName)
    {
        HANDLE hToken;
        if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
            LOG_ERR("failed to open process token, error=%d", GetLastError());
            return false;
        }

        ScopedHandle token(hToken);

        LUID luid;
        if (!LookupPrivilegeValue(NULL, privilegeName, &luid)) {
            LOG_ERR("failed to lookup privilege %s, error=%d",
                privilegeName, GetLastError());
            return false;
        }

        TOKEN_PRIVILEGES tp = {};
        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(hToken, FALSE, &tp,
            sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
            LOG_ERR("failed to adjust token privileges, error=%d", GetLastError());
            return false;
        }

        if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
            LOG_ERR("failed to enable privilege %s (not all assigned)", privilegeName);
            return false;
        }

        LOG_DEBUG("enabled privilege: %s", privilegeName);
        return true;
    }

    DWORD getActiveConsoleSessionId()
    {
        DWORD sessionId = WTSGetActiveConsoleSessionId();

        if (sessionId == 0xFFFFFFFF) {
            LOG_ERR("no active console session found");
            return 0;
        }

        LOG_DEBUG("found active console session: %d", sessionId);
        return sessionId;
    }

    HANDLE getUserTokenFromSession(DWORD sessionId)
    {
        HANDLE hToken = NULL;

        if (!WTSQueryUserToken(sessionId, &hToken)) {
            DWORD error = GetLastError();
            if (error == ERROR_NO_TOKEN) {
                LOG_ERR("no user token in session %d (no user logged on)", sessionId);
            }
            else if (error == ERROR_PRIVILEGE_NOT_HELD) {
                LOG_ERR("insufficient privileges to query user token (need SE_TCB_NAME)");
            }
            else {
                LOG_ERR("failed to query user token for session %d, error=%d",
                    sessionId, error);
            }
            return NULL;
        }

        LOG_DEBUG("obtained user token for session %d", sessionId);
        return hToken;
    }

    std::string getInteractiveUserDesktopPath()
    {
        // Step 1: Enable required privilege
        if (!enablePrivilege(SE_TCB_NAME)) {
            LOG_ERR("failed to enable SE_TCB_NAME privilege");
            return "";
        }

        // Step 2: Get active console session
        DWORD sessionId = getActiveConsoleSessionId();
        if (sessionId == 0) {
            return "";
        }

        // Step 3: Get user token from that session
        HANDLE hToken = getUserTokenFromSession(sessionId);
        if (!hToken) {
            return "";
        }

        ScopedHandle token(hToken);

        // Step 4: Impersonate the user
        ScopedImpersonation impersonate(hToken);
        if (!impersonate.isActive()) {
            return "";
        }

        // Step 5: Get the desktop path using modern API
        PWSTR pszPath = NULL;
        HRESULT hr = SHGetKnownFolderPath(FOLDERID_Desktop,
            0,
            hToken,
            &pszPath);

        if (FAILED(hr)) {
            LOG_ERR("failed to get desktop path, HRESULT=0x%08X", hr);
            return "";
        }

        if (!pszPath) {
            LOG_ERR("desktop path pointer is null");
            return "";
        }

        // Convert wide string to UTF-8
        int size = WideCharToMultiByte(CP_UTF8, 0, pszPath, -1, NULL, 0, NULL, NULL);
        if (size <= 0) {
            LOG_ERR("failed to convert desktop path to UTF-8, error=%d", GetLastError());
            CoTaskMemFree(pszPath);
            return "";
        }

        std::string result(size - 1, '\0');
        WideCharToMultiByte(CP_UTF8, 0, pszPath, -1, &result[0], size, NULL, NULL);

        CoTaskMemFree(pszPath);

        LOG_DEBUG("interactive user desktop path: %s", result.c_str());
        return result;
    }

    ScopedImpersonation::ScopedImpersonation(HANDLE hToken) : m_active(false)
    {
        if (hToken && ImpersonateLoggedOnUser(hToken)) {
            m_active = true;
            LOG_DEBUG("successfully impersonated user");
        }
        else {
            LOG_ERR("failed to impersonate user, error=%d", GetLastError());
        }
    }

    ScopedImpersonation::~ScopedImpersonation()
    {
        if (m_active) {
            RevertToSelf();
            LOG_DEBUG("reverted to original security context");
        }
    }

} // namespace inputleap

#endif // SYSAPI_WIN32
